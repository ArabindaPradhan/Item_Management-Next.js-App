"use client";

import type { Order, AppSettings, CounterResetFrequency } from "@/lib/types";
import React, {
  createContext,
  useContext,
  useEffect,
  useState,
  ReactNode,
  useCallback,
} from "react";
// v4 as uuidv4 is not needed here anymore as IDs should be generated by the backend.

interface AppContextType {
  orders: Order[];
  settings: AppSettings;
  nextOrderSerialNumber: number; // Used for display in form, actual number set by backend
  addOrder: (
    newOrderData: Omit<
      Order,
      "id" | "orderNumber" | "status" | "inTimestamp" | "outTimestamp"
    >
  ) => Promise<void>;
  markOrderAsOut: (orderId: string) => Promise<void>;
  revertOrderToIn: (orderId: string) => Promise<void>;
  updateOrder: (
    orderId: string,
    updatedOrderData: Omit<
      Order,
      "id" | "orderNumber" | "status" | "inTimestamp" | "outTimestamp"
    >
  ) => Promise<void>;

  updateSettings: (newSettings: Partial<AppSettings>) => Promise<void>;
  isLoading: boolean;
  error: string | null;
}

const AppContext = createContext<AppContextType | undefined>(undefined);

const DEFAULT_SETTINGS: AppSettings = {
  maxInTimeMinutes: 60,
  counterResetFrequency: "daily",
  lastResetTimestamp: Date.now(), // This will be primarily managed by backend
};

export const AppProvider = ({ children }: { children: ReactNode }) => {
  const [orders, setOrders] = useState<Order[]>([]);
  const [settings, setSettings] = useState<AppSettings>(DEFAULT_SETTINGS);
  const [nextOrderSerialNumber, setNextOrderSerialNumber] = useState<number>(1);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [settingsResponse, ordersResponse] = await Promise.all([
        fetch("/api/settings"),
        fetch("/api/orders"),
      ]);

      if (!settingsResponse.ok) {
        throw new Error(
          `Failed to fetch settings: ${settingsResponse.statusText}`
        );
      }
      const settingsData = await settingsResponse.json();
      setSettings(settingsData.settings || DEFAULT_SETTINGS);
      setNextOrderSerialNumber(settingsData.nextOrderSerialNumber || 1);

      if (!ordersResponse.ok) {
        throw new Error(`Failed to fetch orders: ${ordersResponse.statusText}`);
      }
      const ordersData = await ordersResponse.json();
      // The API placeholder returns { message: string, example: Order[] }, so access example
      // setOrders(ordersData.example || []);
      console.log("Fetched orders:", ordersData);
      setOrders(ordersData.orders || []);

      // Counter reset logic will now be handled by backend when settings are updated.
      // Frontend can reflect this by re-fetching data if a reset is implied.
    } catch (err) {
      console.error("Failed to load data from API", err);
      setError(
        err instanceof Error ? err.message : "An unknown error occurred"
      );
      // Fallback to defaults if API fails critically
      setOrders([]);
      setSettings(DEFAULT_SETTINGS);
      setNextOrderSerialNumber(1);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const addOrder = async (
    newOrderData: Omit<
      Order,
      "id" | "orderNumber" | "status" | "inTimestamp" | "outTimestamp"
    >
  ) => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch("/api/orders", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(newOrderData),
      });
      if (!response.ok) {
        const errData = await response.json();
        throw new Error(
          errData.message || `Failed to add order: ${response.statusText}`
        );
      }
      const { createdOrder } = await response.json(); // API returns { message, createdOrder }
      setOrders((prevOrders) => [createdOrder, ...prevOrders]);
      // Increment local serial for display in next form, backend confirms actual number
      setNextOrderSerialNumber((prevSerial) => prevSerial + 1);
    } catch (err) {
      console.error("Failed to add order", err);
      setError(err instanceof Error ? err.message : "Failed to add order");
    } finally {
      setIsLoading(false);
    }
  };

  const updateOrder = async (
    orderId: string,
    updatedOrderData: Omit<
      Order,
      "id" | "orderNumber" | "status" | "inTimestamp" | "outTimestamp"
    >
  ) => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch(`/api/orders/${orderId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(updatedOrderData),
      });

      if (!response.ok) {
        const errData = await response.json();
        throw new Error(
          errData.message || `Failed to update order: ${response.statusText}`
        );
      }

      const { updatedOrder } = await response.json(); // API returns { message, updatedOrder }

      setOrders((prevOrders) =>
        prevOrders.map((order) =>
          order.id === updatedOrder.id ? updatedOrder : order
        )
      );
    } catch (err) {
      console.error("Failed to update order", err);
      setError(err instanceof Error ? err.message : "Failed to update order");
    } finally {
      setIsLoading(false);
    }
  };

  const markOrderAsOut = async (orderId: string) => {
    if (!orderId) {
      console.warn("markOrderAsOut: orderId is undefined");
      return;
    }
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch(`/api/orders/${orderId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status: "OUT", outTimestamp: Date.now() }),
      });
      if (!response.ok) {
        const errData = await response.json();
        throw new Error(
          errData.message ||
            `Failed to mark order as OUT: ${response.statusText}`
        );
      }
      const { updatedOrder } = await response.json();
      setOrders((prevOrders) =>
        prevOrders.map((order) =>
          order.id === orderId ? { ...order, ...updatedOrder } : order
        )
      );
    } catch (err) {
      console.error("Failed to mark order as OUT", err);
      setError(err instanceof Error ? err.message : "Failed to mark as OUT");
    } finally {
      setIsLoading(false);
    }
  };

  const revertOrderToIn = async (orderId: string) => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch(`/api/orders/${orderId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status: "IN", outTimestamp: null }), // Clear outTimestamp
      });
      if (!response.ok) {
        const errData = await response.json();
        throw new Error(
          errData.message ||
            `Failed to revert order to IN: ${response.statusText}`
        );
      }
      const { updatedOrder } = await response.json();
      setOrders((prevOrders) =>
        prevOrders.map((order) =>
          order.id === orderId
            ? { ...order, ...updatedOrder, outTimestamp: undefined }
            : order
        )
      );
    } catch (err) {
      console.error("Failed to revert order to IN", err);
      setError(err instanceof Error ? err.message : "Failed to revert to IN");
    } finally {
      setIsLoading(false);
    }
  };

  const updateSettings = async (newSettingsData: Partial<AppSettings>) => {
    setIsLoading(true);
    setError(null);
    try {
      // Determine if a reset is implied by the settings change to pass to backend
      const currentFrequency = settings.counterResetFrequency;
      const newFrequency = newSettingsData.counterResetFrequency;
      let resetCounterSignal = false;
      if (
        newFrequency &&
        newFrequency !== "never" &&
        newFrequency !== currentFrequency
      ) {
        // This is a simplified signal. Backend would have more robust logic.
        // For instance, if changing from 'yearly' to 'daily', a reset might be immediate.
        // The backend should determine if lastResetTimestamp needs updating.
        resetCounterSignal = true;
      }

      const response = await fetch("/api/settings", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          settings: newSettingsData,
          resetCounter: resetCounterSignal,
        }),
      });
      if (!response.ok) {
        const errData = await response.json();
        throw new Error(
          errData.message || `Failed to update settings: ${response.statusText}`
        );
      }
      const {
        settings: updatedSettings,
        nextOrderSerialNumber: updatedSerial,
      } = await response.json();
      setSettings(updatedSettings);
      setNextOrderSerialNumber(updatedSerial);

      // If a reset was signaled and backend confirms it (e.g., serial is 1), refetch orders.
      if (resetCounterSignal && updatedSerial === 1) {
        await fetchData(); // Re-fetch all data to reflect potential reset
      }
    } catch (err) {
      console.error("Failed to update settings", err);
      setError(
        err instanceof Error ? err.message : "Failed to update settings"
      );
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <AppContext.Provider
      value={{
        orders,
        settings,
        nextOrderSerialNumber,
        addOrder,
        markOrderAsOut,
        revertOrderToIn,
        updateOrder,
        updateSettings,
        isLoading,
        error,
      }}
    >
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error("useAppContext must be used within an AppProvider");
  }
  return context;
};
